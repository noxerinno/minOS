Makefile :

#Â Defining cross-compiler vars
CROSS_PREFIX=/opt/cross/i686-elf
CROSS_TARGET=i686-elf

# Defining global vars
SRC_DIR = ./src
BIN_DIR = $(SRC_DIR)/bin
SCRIPT_DIR = $(SRC_DIR)/scripts
DEBUG_SCRIPT = $(SCRIPT_DIR)/debug.sh
REPORTS_DIR = $(SRC_DIR)/bin/reports
DISK_IMAGE_DIR = $(SRC_DIR)/image

UTILS_DIR = ./utils
BUILD_BINUTILS_DIR = $(UTILS_DIR)/build-binutils
BUILD_GCC_DIR = $(UTILS_DIR)/build-gcc

BOOTLOADER_SRC = $(SRC_DIR)/bootloader.asm
BOOTLOADER_BIN_TARGET = $(BIN_DIR)/bootloader.bin
BOOTLOADER_ELF_TARGET = $(BIN_DIR)/bootloader.elf

CC = $(CROSS_PREFIX)/bin/i686-elf-gcc
CFLAGS = -Wall -g
KERNEL_SRC = $(SRC_DIR)/kernel.c
KERNEL_TARGET = $(BIN_DIR)/kernel.elf

LD = $(CROSS_PREFIX)/bin/i686-elf-ld
LINKER = $(SRC_DIR)/linker.ld
OS_ELF_TARGET = $(BIN_DIR)/minOS.elf
OS_DISK_TARGET = $(DISK_IMAGE_DIR)/minOS.img

# Defining prompt colors & utils 
GREEN = \033[0;32m
RED = \033[0;31m
NO_COLOR = \033[0m
NO_PROMPT = 1>/dev/null 2>&1

export PATH := "${PATH}:$(CROSS_PREFIX)/bin"
 	
boot: disk_image
	@ #qemu-system-x86_64 -machine type=pc-i440fx-3.1 -m 512M -drive format=raw,file=$(BOOTLOADER_BIN_TARGET)
	@ #qemu-system-x86_64 -machine type=pc-i440fx-3.1 -m 512M -drive format=raw,file=$(OS_ELF_TARGET)
	@ #qemu-system-x86_64 -drive format=raw,file=$(OS_DISK_TARGET)
	@ qemu-system-i386 -drive format=raw,file=$(OS_DISK_TARGET)


debug: boot elf_reports
	@ chmod u+x $(DEBUG_SCRIPT)
	@ $(DEBUG_SCRIPT)

# disk_image: create_disk_image_dir
# 	@ dd if=/dev/zero of=$(OS_DISK_TARGET) bs=512 count=2880
# 	@ dd if=$(OS_ELF_TARGET) of=$(OS_DISK_TARGET) conv=notrunc
# 	@ echo "${GREEN}Disk image: ${NO_COLOR}Disk image successfully created at $(OS_DISK_TARGET)"

disk_image: binaries create_disk_image_dir
	@ dd if=/dev/zero of=$(OS_DISK_TARGET) bs=512 count=2880
	@ dd if=$(BOOTLOADER_BIN_TARGET) of=$(OS_DISK_TARGET) conv=notrunc
	@ dd if=$(KERNEL_TARGET) of=$(OS_DISK_TARGET) bs=512 seek=1 conv=notrunc
	@ echo "${GREEN}Disk image: ${NO_COLOR}Disk image successfully created at $(OS_DISK_TARGET)"

binaries: clean_bin create_bin_dir
	@ if [ ! -d $(CROSS_PREFIX) ]; then \
		echo "${RED}Binaries: ${NO_COLOR}Cross compiler not found in \"$(CROSS_PREFIX)\"\n\t  To install the i386-elf cross compiler, run the following commands :\n\t\tsudo make cross-compiler &&\n\t\tcd $(BUILD_BINUTILS_DIR) && sudo ./binutils-config.sh && cd - &&\n\t\tcd $(BUILD_GCC_DIR) && sudo ./gcc-config.sh && cd -"; \
		exit 1; \
	fi

	@ nasm -f bin -o $(BOOTLOADER_BIN_TARGET) $(BOOTLOADER_SRC)
	@ nasm -f elf32 -o $(BOOTLOADER_ELF_TARGET) $(BOOTLOADER_SRC)
	@ $(CC) $(CFLAGS) -o $(KERNEL_TARGET) -c $(KERNEL_SRC)
	@ $(LD) -T $(LINKER) -o $(OS_ELF_TARGET) $(BOOTLOADER_ELF_TARGET) $(KERNEL_TARGET)
	@ echo "${GREEN}Binaries: ${NO_COLOR}Bootloader & kernel binaries successfully compiled in $(BIN_DIR)"

elf_reports:	create_elf_reports_dir
	@ readelf -a $(BOOTLOADER_ELF_TARGET) > $(REPORTS_DIR)/bootloader_bin_report.txt 
	@ readelf -a $(KERNEL_TARGET) > $(REPORTS_DIR)/kernel_elf_report.txt
	@ readelf -a $(OS_ELF_TARGET) > $(REPORTS_DIR)/os_elf_report.txt 
	@ echo "${GREEN}Reports: ${NO_COLOR}Reports created"

create_bin_dir:
	@ if [ ! -d $(BIN_DIR) ]; then \
		mkdir $(BIN_DIR); \
		echo "${GREEN}Binaries: ${NO_COLOR}Binaries directory created"; \
	fi

create_disk_image_dir:
	@ if [ ! -d $(DISK_IMAGE_DIR) ]; then \
		mkdir $(DISK_IMAGE_DIR); \
		echo "${GREEN}Binaries: ${NO_COLOR}Binaries directory created"; \
	fi


create_elf_reports_dir:
	@ if [ ! -d $(REPORTS_DIR) ]; then \
		mkdir -p $(REPORTS_DIR); \
		echo "${GREEN}Reports: ${NO_COLOR}Reports directory successfully created"; \
	fi

clean_bin:
	@ rm -rdf $(BIN_DIR)/*
	@ echo "${GREEN}Cleaner: ${NO_COLOR}Binaries cleaned"

mr_proper:
	@ rm -rdf $(BIN_DIR)
	@ rm -rdf $(UTILS_DIR)
	@ echo "${GREEN}Mr Proper: ${NO_COLOR}Project cleaned"



# Cross compiler creation target
cross-compiler: create_binutils_dir create_gcc_dir
	@ sudo apt update $(NO_PROMPT)
	@ sudo apt install build-essential bison flex libgmp3-dev libmpc-dev libmpfr-dev texinfo $(NO_PROMPT)
	@ echo "${GREEN}Cross compiler: ${NO_COLOR}Dependencies installed"
	
	@ if ! ls -A $(UTILS_DIR) | grep \"binutils-.*\.tar\.gz\"; then \
		wget https://ftp.gnu.org/gnu/binutils/binutils-2.41.tar.gz -P $(UTILS_DIR) $(NO_PROMPT); \
		tar -xzf $(UTILS_DIR)/binutils-2.41.tar.gz -C $(UTILS_DIR) $(NO_PROMPT); \
	fi
	@ if ! ls -A $(UTILS_DIR) | grep \"gcc-.*\.tar\.gz\"; then \
		wget https://ftp.gnu.org/gnu/gcc/gcc-13.2.0/gcc-13.2.0.tar.gz -P $(UTILS_DIR) $(NO_PROMPT); \
		tar -xzf $(UTILS_DIR)/gcc-13.2.0.tar.gz -C $(UTILS_DIR) $(NO_PROMPT); \
	fi
	@ echo "${GREEN}Cross compiler: ${NO_COLOR}Sources downloads"
	
	@ cp $(SCRIPT_DIR)/binutils-config.sh $(BUILD_BINUTILS_DIR)
	@ chmod u+x $(BUILD_BINUTILS_DIR)/binutils-config.sh
	@ echo "${GREEN}Cross compiler: ${NO_COLOR}Binutils configuration setup"

	@ cp $(SCRIPT_DIR)/gcc-config.sh $(BUILD_GCC_DIR)
	@ chmod u+x $(BUILD_GCC_DIR)/gcc-config.sh
	@ echo "${GREEN}Cross compiler: ${NO_COLOR}GCC configuration setup"	

create_binutils_dir:
	@ if [ ! -d $(BUILD_BINUTILS_DIR) ]; then \
		mkdir -p $(BUILD_BINUTILS_DIR); \
		echo "${GREEN}Cross compiler: ${NO_COLOR}Binutils directory created"; \
	fi

create_gcc_dir:
	@ if [ ! -d $(BUILD_GCC_DIR) ]; then \
		mkdir -p $(BUILD_GCC_DIR); \
		echo "${GREEN}Cross compiler: ${NO_COLOR}GCC sources directory created"; \
	fi

clean_utils:
	@ rm -rdf $(UTILS_DIR)
	@ echo "${GREEN}Cleaner: ${NO_COLOR}Utils cleaned"

# boot: binaries
# 	@ qemu-system-x86_64 -M pc -m 512M -nographic -kernel ./src/bin/bootloader.elf
#
# debug: binaries elf_report
# 	@ qemu-system-x86_64 -machine type=pc-i440fx-3.1 -m 512M -kernel ./src/bin/bootloader.elf --append "console=tty0 console=ttyS0"


bootloader.asm :

[BITS 16]

section .text
global _start

BOOT_DRIVE db 0x00

_start:
    mov ax, 0x07C0          ; Load bootloader load address in AX (0x7C0:0000 = 0x7C00)
    mov ds, ax
    call clear_screen       ; Call the function to clear the screen
    
    mov dl, 25              ; Heigth offset to center the logo (80x25 display)
    mov dh, 9               ; Heigth offset to center the logo (80x25 display)
    call set_cursor         ; Call the functioon to set the cursor at the right offset
    mov si, logo_line1      ; Load the address of 'my_string' into bx
    call print_screen       ; Call the function to print the string
    
    mov dh, 10              ; Displaying logo's second line
    call set_cursor
    mov si, logo_line2
    call print_screen

    mov dh, 11              ; Displaying logo's third line
    call set_cursor
    mov si, logo_line3
    call print_screen

    mov dh, 12              ; Displaying logo's fourth line
    call set_cursor
    mov si, logo_line4
    call print_screen

    mov dh, 13              ; Displaying logo's fifth line
    call set_cursor
    mov si, logo_line5
    call print_screen

    mov dh, 14              ; Displaying logo's sixth line
    call set_cursor
    mov si, logo_line6
    call print_screen

    call sleep_5_seconds
    call clear_screen

    ;jmp $                   ; Infinite loop to stay in the bootloader

    ; Preparing swith to protected mode
    ; Basic Flat Model (BFM) for the Global Descriptor Table (GDT)
    gdt_start:              ; Required null descriptor
        dw 0x0
        dw 0x0
    
    gdt_data:               ; Data semgment
        dw 0xffff           ; Span over whole available space
        dw 0x0
        db 0x0
        db 10010010b        ; Readable, writable but not executable
        db 11001111b
        db 0x0
    
    gdt_code:               ; Code segment
        dw 0xffff           ; Span over whole available space
        dw 0x0
        db 0x0
        db 10011010b        ; Readable, executable but not writable
        db 11001111b
        db 0x0
    
    gdt_end:    
    
    gdt_descriptor:
        dw gdt_end - gdt_start - 1
        dw gdt_start

    ; Kernel loading
    mov bx, 0x1000          ; Load OS source code in memory at address 0x1000
    mov dh, 16              ; Laod 16 disk sectors
    mov dl, [BOOT_DRIVE]    ; Load from booting disk
    mov ah, 0x02            ; BIOS function to load disk
    mov al, dh              ; Provide the number of sector to load to the BIOS function
    mov cl, 0x02            ; Read from sector 2,...
    mov ch, 0x00            ; ...from cylinder 0...
    mov dh, 0x00            ; ...and from head 0
    int 0x13                ; Call to the BIOS interrupt to pass kernel's main func

    cli                     ; Disable BIOS interrupts
    lgdt[gdt_descriptor]    ; Load the GDT

    mov eax, cr0            ; Load control register 0 (CR0)
    or al, 1                ; Set the PE (Protection Enable) bit
    mov cr0, eax            ; Write back to CR0 to enable protected mode

    jmp 0x08:protected_start; Long jump

clear_screen:
    mov ah, 0x06            ; BIOS teletype function (0x06) for clearing the screen  
    mov al, 0x00            ; Clear whole screen 
    mov bh, 0x07            ; Write in white on black background
    mov cx, 0x0000          ; Upper left screen coordinate
    mov dx, 0x184F          ; Lower right screen coordinate
    int 0x10                ; Make the BIOS interrupt call to print the character
    jmp done

set_cursor:                 ; Position cursor to center print
    mov ah, 0x02            ; BIOS teletype function (0x06) for placing the cursor
    mov bh, 0x00
    int 0x10                ; Make the BIOS interrupt call to print the character
    jmp done

print_screen:
    mov al, [si]            ; Load the character pointed to by bx into al

    cmp al, 0               ; Check if the character is the null terminator (end of string)
    je done                 ; If it's null (0), jump to 'done'

    mov ah, 0x0E            ; BIOS teletype function (0x0E) for printing a character
    int 0x10                ; Make the BIOS interrupt call to print the character

    add si, 1               ; Increment bx to point to the next character
    jmp print_screen        ; Repeat for the next character 

; Qemu doesn't seem to correctly use int 0x15, func 0x86
;sleep_5_seconds:
;    mov cx, 0               ; Set CX (high word of the delay) to 0, as our delay is less than 65536 ms
;    mov dx, 5000            ; Set DX (low word of the delay) to 5000 milliseconds (5 seconds)
;    
;    mov ah, 0x86            ; BIOS interrupt function 0x86 for waiting (delay)
;    int 0x15                ; Call BIOS interrupt 0x15 to perform the delay 
;    jmp done

; Custom 'sleep' function
sleep_5_seconds:
    mov cx, 0x4FFF          ; Outer loop counter
outer_loop:
    mov dx, 0xFFFF          ; Inner loop counter
inner_loop:
    dec dx                  ; Decrement inner loop counter
    jnz inner_loop          ; If DX != 0, repeat inner loop
    
    dec cx                  ; Decrement outer loop counter
    jnz outer_loop          ; If CX != 0, repeat outer loop
    
    jmp done

done:
    ret                     ; Return from the function when the string ends

logo_line1 db " __  __ _        ____   _____", 0  ; Null-terminated string
logo_line2 db "|  \/  (_)      / __ \ / ____|", 0  
logo_line3 db "| \  / |_ _ __ | |  | | (___", 0  
logo_line4 db "| |\/| | | '_ \| |  | |\___ \", 0
logo_line5 db "| |  | | | | | | |__| |____) |", 0
logo_line6 db "|_|  |_|_|_| |_|\____/|_____/", 0


protected_start:
    mov ax, 0x10            ; Selecting data segments
    mov ds, ax              ; Loading data segments
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax              ; Loading stack data

    jmp 0x08:0x1000         ; Long jump to kernel


times 510-($-$$) db 0       ; Fill empty space with '0'
bootSignature dw 0xAA55     ; Write boot signature at the end of the boot sector


kernel.c :

int main() {
    const char *message = "Hello from my kernel!";
    char *vidmem = (char *)0xB8000; // Video memory address

    for (int i = 0; message[i] != '\0'; i++) {
        vidmem[i * 2] = message[i]; // Print char
        vidmem[i * 2 + 1] = 0x07;   // Print on white over black
    }

    while (1) {}

    return 0;
}


linker.ld :

OUTPUT_FORMAT(elf32-i386)
ENTRY(_start)

SECTIONS {
    . = 0x000000;
    .bootloader : {
        *(.text)
    }

    . = ALIGN(0x1000);
    .kernel : {
        *(.text) *(.rodata) *(.data) *(.bss)
    }
}
